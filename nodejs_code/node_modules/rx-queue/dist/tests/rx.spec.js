#!/usr/bin/env ts-node
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as test from 'blue-tape';
import { interval, asyncScheduler, } from 'rxjs';
import { map, take, } from 'rxjs/operators';
import { TestScheduler, } from 'rxjs/testing';
/**
 * See: https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md
 * See Also: https://github.com/ohjames/rxjs-websockets/blob/master/src/index.spec.ts
 */
test('marble smoke testing', (t) => __awaiter(this, void 0, void 0, function* () {
    function timeRange(start, end, step = 1000, schedulerX = asyncScheduler) {
        return interval(step, schedulerX).pipe(map(n => n + start), take(end - start + 1));
    }
    const scheduler = new TestScheduler((actual, expected) => {
        // console.log('Actual:', actual, '\n\n', 'Expected:', expected);
        t.ok(JSON.stringify(actual) === JSON.stringify(expected), 'two observable should be equal to the defination from marble diagram');
    });
    const source = timeRange(2, 8, 50, scheduler);
    const values = { '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8 };
    scheduler.expectObservable(source).toBe('-----2----3----4----5----6----7----(8|)', values),
        scheduler.flush();
}));
//# sourceMappingURL=rx.spec.js.map