#!/usr/bin/env ts-node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator];
    return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
// tslint:disable:no-shadowed-variable
const test = require("blue-tape");
const fixtures_1 = require("../tests/fixtures");
const hot_import_1 = require("./hot-import");
// import { log }      from 'brolog'
// log.level('silly')
const EXPECTED_TEXT = 'testing123';
test('callerResolve()', (t) => __awaiter(this, void 0, void 0, function* () {
    const RELATIVE_FILE_PATH = './test';
    const ABSOLUTE_FILE_PATH = path.resolve(__dirname, RELATIVE_FILE_PATH);
    t.test('relative file path', (t) => __awaiter(this, void 0, void 0, function* () {
        const filePath = hot_import_1.callerResolve(RELATIVE_FILE_PATH);
        t.equal(filePath, ABSOLUTE_FILE_PATH, 'should turn relative to absolute');
    }));
    t.test('absolute file path', (t) => __awaiter(this, void 0, void 0, function* () {
        const filePath = hot_import_1.callerResolve(ABSOLUTE_FILE_PATH);
        t.equal(filePath, ABSOLUTE_FILE_PATH, 'should keep absolute as it is');
    }));
    t.test('callerExceptFile', (t) => __awaiter(this, void 0, void 0, function* () {
        const filePath = hot_import_1.callerResolve(RELATIVE_FILE_PATH, __filename);
        // console.log(filePath)
        t.assert(filePath.endsWith(path.join(// cross platform: compatible with windows
        'node_modules', 'tape', 'lib', 'test')), 'except the current file name');
    }));
}));
test('newCall()', (t) => __awaiter(this, void 0, void 0, function* () {
    class TextClass {
        constructor(text) {
            this.text = text;
        }
    }
    const textClass = hot_import_1.newCall(TextClass, EXPECTED_TEXT);
    t.equal(textClass.text, EXPECTED_TEXT, 'should instanciate class with constructor arguments');
}));
test('hotImport()', (t) => __awaiter(this, void 0, void 0, function* () {
    t.test('class module(export=)', (t) => __awaiter(this, void 0, void 0, function* () {
        let file, cls;
        try {
            for (var _a = __asyncValues(fixtures_1.changingClassModuleFixtures()), _b; _b = yield _a.next(), !_b.done;) {
                const info = yield _b.value;
                /**
                 * io event loop wait for fs.watch
                 * FIXME: Find out the reason...
                 */
                yield new Promise(setImmediate); // the first one is enough for Linux(Ubuntu 17.04)
                yield new Promise(setImmediate); // the second one is needed for Windows 7
                if (!cls) {
                    file = info.file;
                    cls = yield hot_import_1.hotImport(file);
                }
                else {
                    t.equal(file, info.file, 'should get same module file for fixtures(change file content only)');
                }
                yield new Promise(resolve => setTimeout(resolve, 10));
                const result = new cls(EXPECTED_TEXT);
                t.equal(result.text, EXPECTED_TEXT, 'should get expected values from instance of class in module');
                t.equal(result.id, info.returnValue, 'should import module class with right id:' + info.returnValue);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) yield _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (file) {
            yield hot_import_1.hotImport(file, false);
        }
        var e_1, _c;
    }));
    t.test('variable module(export const answer=)', (t) => __awaiter(this, void 0, void 0, function* () {
        let file, hotMod;
        try {
            for (var _d = __asyncValues(fixtures_1.changingVariableModuleFixtures()), _e; _e = yield _d.next(), !_e.done;) {
                const info = yield _e.value;
                /**
                 * io event loop wait for fs.watch
                 * FIXME: Find out the reason...
                 */
                yield new Promise(setImmediate); // the first one is enough for Linux(Ubuntu 17.04) with Node.js v8
                yield new Promise(setImmediate); // the second one is needed for Windows 7
                if (!hotMod) {
                    file = info.file;
                    hotMod = yield hot_import_1.hotImport(file);
                }
                else {
                    t.equal(file, info.file, 'should get same module file for fixtures(change file content only)');
                }
                yield new Promise(resolve => setTimeout(resolve, 10));
                t.equal(hotMod.answer, info.returnValue, 'should get expected values from variable in module');
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_f = _d.return)) yield _f.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (file) {
            yield hot_import_1.hotImport(file, false);
        }
        var e_2, _f;
    }));
    t.test('raw export module(export = () => "value")', (t) => __awaiter(this, void 0, void 0, function* () {
        let file, hotMod;
        try {
            for (var _g = __asyncValues(fixtures_1.changingRawFuncModuleFixtures()), _h; _h = yield _g.next(), !_h.done;) {
                const info = yield _h.value;
                /**
                 * io event loop wait for fs.watch
                 * FIXME: Find out the reason...
                 */
                yield new Promise(setImmediate); // the first one is enough for Linux(Ubuntu 17.04) with Node.js v8
                yield new Promise(setImmediate); // the second one is needed for Windows 7
                if (!hotMod) {
                    file = info.file;
                    hotMod = yield hot_import_1.hotImport(file);
                }
                else {
                    t.equal(file, info.file, 'should get same module file for fixtures(change file content only)');
                }
                yield new Promise(resolve => setTimeout(resolve, 10));
                t.equal(hotMod(), info.returnValue, 'should get expected values from the return value of raw func in module');
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_j = _g.return)) yield _j.call(_g);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (file) {
            yield hot_import_1.hotImport(file, false);
        }
        var e_3, _j;
    }));
    t.test('module that only has a default export', (t) => __awaiter(this, void 0, void 0, function* () {
        const EXPECTED_RETURN_VALUE = 42;
        const DEFAULT_EXPORT_ONLY_MODULE_FILE = '../tests/fixtures/default-export-module';
        const mod = yield hot_import_1.hotImport(DEFAULT_EXPORT_ONLY_MODULE_FILE);
        t.equal(mod(), EXPECTED_RETURN_VALUE, 'should get the default export function return value right');
        hot_import_1.hotImport(DEFAULT_EXPORT_ONLY_MODULE_FILE, false);
    }));
}));
test('importFile()', (t) => __awaiter(this, void 0, void 0, function* () {
    t.test('const value', (t) => __awaiter(this, void 0, void 0, function* () {
        try {
            for (var _k = __asyncValues(fixtures_1.changingVariableModuleFixtures()), _l; _l = yield _k.next(), !_l.done;) {
                const info = yield _l.value;
                const hotMod = yield hot_import_1.importFile(info.file);
                t.equal(hotMod.answer, info.returnValue, 'should import file right with returned value ' + info.returnValue);
                break; // only test once for importFile
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_l && !_l.done && (_m = _k.return)) yield _m.call(_k);
            }
            finally { if (e_4) throw e_4.error; }
        }
        var e_4, _m;
    }));
    t.test('class', (t) => __awaiter(this, void 0, void 0, function* () {
        try {
            for (var _o = __asyncValues(fixtures_1.changingClassModuleFixtures()), _p; _p = yield _o.next(), !_p.done;) {
                const info = yield _p.value;
                const m = yield hot_import_1.importFile(info.file);
                const result = new m(EXPECTED_TEXT);
                t.equal(result.text, EXPECTED_TEXT, 'should instanciated class with constructor argument');
                t.equal(result.id, info.returnValue, 'should import module class with right id');
                break; // only test once for importFile
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_p && !_p.done && (_q = _o.return)) yield _q.call(_o);
            }
            finally { if (e_5) throw e_5.error; }
        }
        var e_5, _q;
    }));
}));
test('refreshImport()', (t) => __awaiter(this, void 0, void 0, function* () {
    let cls;
    try {
        for (var _r = __asyncValues(fixtures_1.changingClassModuleFixtures()), _s; _s = yield _r.next(), !_s.done;) {
            const info = yield _s.value;
            if (!cls) {
                cls = yield hot_import_1.importFile(info.file);
                hot_import_1.moduleStore[info.file] = cls;
                hot_import_1.proxyStore[info.file] = hot_import_1.initProxyModule(info.file);
            }
            else {
                yield hot_import_1.refreshImport(info.file);
                t.notEqual(hot_import_1.moduleStore[info.file], cls, 'should be refreshed to new value');
            }
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (_s && !_s.done && (_t = _r.return)) yield _t.call(_r);
        }
        finally { if (e_6) throw e_6.error; }
    }
    var e_6, _t;
}));
test('purgeRequireCache()', (t) => __awaiter(this, void 0, void 0, function* () {
    const KEY = 'test-key';
    const VAL = 'test-val';
    for (const info of fixtures_1.emptyObjectModuleFixture()) {
        const m0 = yield hot_import_1.importFile(info.file);
        t.deepEqual(m0, info.returnValue, 'should get returnValue from module');
        m0[KEY] = VAL;
        const m1 = yield hot_import_1.importFile(info.file);
        t.equal(m1[KEY], VAL, 'should keep value in require cache');
        hot_import_1.purgeRequireCache(info.file);
        const m2 = yield hot_import_1.importFile(info.file);
        t.deepEqual(m2, info.returnValue, 'should get returnValue again after purge');
        t.equal(m2[KEY], undefined, 'should no KEY exists any more');
    }
}));
test('cloneProperties()', (t) => __awaiter(this, void 0, void 0, function* () {
    const SRC = { text: EXPECTED_TEXT };
    const SRC_CLASS = class {
        constructor(text) {
            this.text = text;
        }
    };
    t.test('object', (t) => __awaiter(this, void 0, void 0, function* () {
        const dst = {};
        hot_import_1.cloneProperties(dst, SRC);
        t.equal(dst.text, EXPECTED_TEXT, 'should clone the text property');
    }));
    t.test('class', (t) => __awaiter(this, void 0, void 0, function* () {
        const dst = {};
        hot_import_1.cloneProperties(dst, SRC_CLASS);
        t.equal(SRC_CLASS.prototype, dst.prototype, 'should clone the prototype for class');
    }));
}));
test('VERSION', (t) => __awaiter(this, void 0, void 0, function* () {
    t.ok(hot_import_1.VERSION.match(/^\d+\.\d+\.\d+$/), 'should get semver version');
}));
//# sourceMappingURL=hot-import.spec.js.map